# JVM学习

## 类的加载

![](C:\Users\victor\learn\学习资料\JVM\image\Snipaste_2021-03-18_22-14-42.png)

加载的类的信息放在一块称为方法区的内存空间，除了类信息外还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

方法区中放的是加载的类的信息与运行时常量池信息

**加载阶段：**

1. 通过类的全限定类名获取到定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据访问的入口

**链接阶段：**

- 验证：确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的重要性，不会威海虚拟机自身安全
- 准备：为类变量分配内存并设置该变量的默认初始值。这里不包含final修饰的static，因为final在编译时，会给他一个特殊的特征，准备阶段在显示初始化。不会给实例变量分配初始化。
- 解析：将常量池内的符号引用转换为直接引用的过程

**初始化过程：**

- 初始化过程就是执行类构造方法<clinit>()的过程，此方法不需要定义，在编译时自动收集所有类变量的赋值操作和静态代码块中的语句。
- 构造器方法按语句在源文件中的位置执行
- <clinit>()不同于类的构造器
- 若该类具有父类，那么会在<clinit>()方法执行结束前，父类的<clinit>()的已经执行完毕
- 虚拟机必须保证一个类的<clinit>()在多线程下同步加锁

#### 类加载器

**引导类加载**：**Bootstrap ClassLoader**(C++编写，JVM的一部分，加载java的核心类库，没有父类加载器，只加载包名：java、javax、sun开头的文件)

**自定义加载器**：

- **Extension ClassLoader**（虚拟机自带的加载器，java编写，派生于ClassLoader类，只加载指定路径的类库）
- **APP ClassLoader**（虚拟机自带的，java编写，派生于ClassLoader，负责加载环境classpath或系统指定的路径下的类库，程序中默认的加载器）

**为什么自定义类加载器**

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露

#### 双亲委派机制

java采用的是按需加载，什么时候需要这个类什么时候加载，加载这个类的时候采用的是双亲委派机制，把请求交给父类处理。加载一个类时，看类加载器有没有父类加载器，如果有则交给父类处理，直到没有父类为止，如果是Bootstrap ClassLoader加载的内容则加载此类，如果不是在下来找子类加载器加载

优势：避免类的重复加载，防止核心API被篡改

#### 沙箱安全机制

自定义一个java.lang.String类里面写一个main方法，当运行时会报String类里没有main函数的错误，因为加载的是自带的String类，这就是沙箱安全机制



判断两个class对象是否为同一个类的必要条件：

1. 类的全限定类名一致
2. 加载这个类的classLoader必须一致



## 运行时数据区

![](/home/victor/learn/运行时内存结构.jpg)

注：每个线程都包含各自的本地方法栈、虚拟机栈、程序计数器，堆与元数据区（方法区）是线程间共享的，一个进程就一个，随虚拟机的启动而创建，虚拟机销毁也随之销毁。

### 程序计数器（速度最快）

用来存储下一行指令的地址，由执行引擎读取下一条指令

堆与方法区存在垃圾回收，程序计数器不会存在内存溢出问题，栈结构、堆、方法区可能会溢出。

### 虚拟机栈（栈是运行时单位，堆是存储的单位）

内部保存一个一个的栈帧，其对应的是一个一个的方法。主管java程序的运行，保存方法的局部变量，部分结果，并参与方法的调用与返回。

可以通过-Xss调整栈的大小

**栈**

栈帧：是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息

栈帧：包含局部变量表、方法返回地址、操作数栈、动态链接、一些附加信息

#### **局部变量表**

定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，有基本数据类型与引用数据类型。局部变量表的大小在编译时期就确定了，在方法运行期间不会改变他的大小。局部变量表最基本的存储单元是槽（Slot），32位以内的占用一个slot（包括引用类型），64位占两个slot（long，double）

如果当前帧是由构造函数或者实例方法创建的，那么该对象引用this将会存放到index为0的slot处，其余的按参数表顺序继续排列。所以在static修饰的方法中不能使用this，因为他的局部变量表中没有this

栈帧中的局部变量表中的slot是可以重复利用的，当一个局部变量出了它的作用域则他所在的slot就会让出来给其他变量

局部变量表当中的变量是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会回收

**变量**

- 成员变量（都经过默认初始化赋值）
  - 类变量：在链接阶段会赋默认值，在初始化阶段进行显示赋值
  - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值 
- 局部变量：使用前必须进行显示赋值！否则编译不通过

#### 操作数栈

主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，操作数栈的深度在编译时就确定了，32bit的类型占用一个栈单位深度，64bit占用两个栈单位深度。如果调用的方法有返回值，则把返回值压入当前栈帧的操作数栈中

#### 栈顶缓存技术

将栈顶元素全部缓存到物理CPU的寄存器中，以此降低堆内存的读写次数，提升执行引擎的执行效率

#### 动态链接

每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的是为了支持当前方法的代码能够实现动态链接

在java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用保存在class文件的常量池中，比如描述一个方法调用另一个方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用。

常量池的作用：就是为了提供一些符号与常量，便于指令的识别，方便调用

#### 方法的调用

- 静态链接：如果目标方法在编译期可知，且运行期间保持不变，这种情况下调用方法的符号引用转换为直接引用的过程称为静态链接
- 动态链接：被调用的方法在编译期无法确认下来，将这种方法的符号引用转化为直接引用的过程称为动态链接，因为其转化具有动态性

**虚方法：**剩下所有都是虚方法

**非虚方法：**静态方法、私有方法、final修饰的方法、实例构造器、父类方法

#### 方法返回地址

存放该方法程序计数器的值

方法返回地址、动态链接、一些附加信息同称帧数据区

正常完成出口与异常完成出口的区别在于：通过异常完成出口退出的不会给他上层调用者产生任何的返回值

#### 一些附加信息

携带一些与java虚拟机实现相关的一些附加信息

### 本地方法栈

管理本地方法的掉用

## 堆

堆中不是所有空间都是共享的，其中有一小部分（TLAB）是线程私有的

jdk7逻辑上三个分区：新生代、年老代、永久带

jdk8逻辑上三个分区：新生代、年老代、元空间

逻辑上分三个区域，实际上只能管理新生代与年老代

-Xms：用来设置堆空间（新生代、年老代）的初始内存大小，默认情况下，物理内存大小 / 64

-Xmx：用来设置堆空间（新生代、年老代）的最大内存大小，默认情况下，物理内存大小 / 4。开发中建议设置初始与最大是一样的值，因为频繁的扩容与释放造成系统不必要的压力，影响性能

配置新生代与老年代的堆结构占比：默认-XX：NewRatio=2，表示新生代占1，老年代占2

Eden区与另外两个幸存者区：8：1：1

几乎所有的对象都是在Eden中被创建出来，绝大多数java对象的销毁都在新生代中进行了

![](/home/victor/learn/创建对象流程.jpg)

![](/home/victor/learn/创建对象流程（细节）.jpg)

1. 创建对象在Eden区

2. 当Eden满了，触发MinorGC（YoungGC）把继续使用的对象放到survivor0区，年龄为1，不用的进行释放

3. 当Eden再次满了，继续MinorGC放到没有使用的survivor1区，然后把survivor0区中继续使用的放到（使用赋复制算法）survivor1区中，年龄+1

4. 当年龄到达15这个默认阈值时，此对象放到老年代

   注：频繁在新生代中垃圾回收，较少在老年代，几乎不在永久代/元空间中收集

   

**Minor GC： ** **Major GC：** **Full GC：**

按回收区域分为量大类型：部分收集、整堆收集

- 部分收集：不是完整收集整个java堆的垃圾收集

  - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集

    - 当年轻代空间不足时会触发，这里年轻代指的是Eden，幸存者区满并不会触发。java对象一般都具有朝生熄灭的特性，所以频繁触发Minor GC。
    - Minor GC会出发STW（Stop The World）暂停其他用户线程，等垃圾回收结束，用户线程才回复运行

  - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集

    目前只有CMS GC 会有单独收集老年代的行为

    很多时候Major GC回合Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收

  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集

    目前只有G1 GC 会有这种行为

- 整堆收集（Full GC）：收集整个java堆和方法区的垃圾

**老年代GC（Major GC / Full GC）**

出现了Major GC时，经常会伴随至少一次的Minor GC。

老年代空间不足时，会先尝试触发Minor GC，如果空间 还不足，则会触发Major GC

Major GC的速度会比Minor GC慢10倍以上，STW时间更长，如果Major GC后空间还不足就报OOM了



**Full GC触发机制**

1. System.gc()时，建议执行Full GC，但是不必然执行

2. 老年代空间不足

3. 方法区空间不足

4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存

5. 由Eden区、幸存者0区向幸存者1区复制时，对象大于to区的可用空间，把对象转存到老年代，且老年代的可用空间小于对象的大小

   注：Full GC 是开发中尽量避免的，这样暂停时间会短一些



**TLAB**（仅占Eden的百分之一）

从内存模型而不是垃圾回收角度，对Eden区继续进行划分，JVM为每个线程分配了一个私有缓冲区，他包含在Eden区中

多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能提升内存分配的吞吐量，因为我们将这种内存分配方式称为快速分配策略

尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选

一旦对象在TLAB空间分配内存失败时，JVM会尝试使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存



**堆是分配对象的唯一选择吗**

在java虚拟机中，对象是在java堆中分配内存的，但是有一种特殊情况，那就是如果经过逃逸分析后发现，一个对象并没有陶一处方法的话，那么就可能被优化成栈上分配，这样就无需在堆上分配内存，也无需进行垃圾回收。这是最常见的堆外存储技术



垃圾回收

#### 标记阶段：引用计数法（缺点：循环引用）、可达性分析算法

#### 清楚阶段：

##### 标记清除算法：

标记所有被引用的对象，在堆内从头到尾进行线性遍历，发现某个对象在对象头中没有标记为可达对象，则将其回收

缺点：产生内存碎片，需要维护一个空闲列表，效率低

##### 复制算法：

将活着的内存空间分为两块，每次只用一块，在垃圾回收时，把活着的对象复制到另一块中，之后清楚本快中所有对象，交换内存角色，完成垃圾回收

优点：实现简单、运行高效，不会出现内存碎片

缺点：需要两倍空间，如果垃圾少效率低

##### 标记压缩（整理）算法：

标记所有可达的存活对象，将所有存活对象压缩到内存的一端，按顺序排放，之后清理边界外所有的空间

优点：消除碎片化内存，不会像复制算法需要两倍空间

缺点：效率低于复制算法，移动对象同时，被用户引用需要一同修改，移动过程全程STW

效率：复制算法》标记清除算法》标记压缩（整理）算法

##### 分代收集算法：

年轻代使用复制算法

老年代使用标记清楚与标记压缩混合实现































